# Basic CI/CD


## Part 1. Настройка **gitlab-runner**

**== Задание ==**

### Поднять виртуальную машину *Ubuntu Server 22.04 LTS*

![1.1](images/1-1.png) 

### Скачать и установить на виртуальную машину **gitlab-runner**

> Был выбран метод установки gitlab-runner через [бинарный файл с официального сайта](https://docs.gitlab.com/runner/install/linux-manually.html)

Нужно загрузить бинарный файл <br>
```sh
sudo curl -L --output /usr/local/bin/gitlab-runner "https://s3.dualstack.us-east-1.amazonaws.com/gitlab-runner-downloads/latest/binaries/gitlab-runner-linux-amd64"
```

![1.2](images/1-2.png) 

Даём файлу разрешение на исполнение: <br>
```sh
sudo chmod +x /usr/local/bin/gitlab-runner
```
![1.3](images/1-3.png) 
Создаём пользователя GitLab CI <br>
```sh
sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash
```
![1.4](images/1-4.png) 

Установить как службу <br>
```sh
sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner
```
![1.5](images/1-5.png) 

Запустить службу
```sh
sudo gitlab-runner run
```
![1.6](images/1-7.png) 

### Запустить **gitlab-runner** и зарегистрировать его для использования в текущем проекте (*DO6_CICD*)



- Зарегистрировать gitlab-runner
```ssh
sudo gitlab-runner register
```
![1.7](images/1-6.png) 
> Для этого необходимо ввести данные при регистрации: <br>
> 1. Cвой URL-адрес GitLab
> 2. Cвой регистрационный токен
> 3. Название раннера
> 4. Теги для заданий, разделенные запятыми
> 5. Тип исполнителя

<br>




## Part 2. Сборка

### Напиcать этап для CI по сборке приложений из проекта *C2_SimpleBashUtils*

- В корне репозитория создать файл `.gitlab-ci.yml`

```ssh
touch .gitlab-ci.yml
```

- Добавить в файл этап запуска сборки через мейк файл из проекта C2.

> Настроим также этап, чтобы файлы, полученные после сборки (артефакты), сохранялись со сроком хранения 30 дней.

![2.1](images/2-1.png)

### Неподготовленная оболочка

- При пуше мы столкнемся со следующей ошибкой

![2.2](images/2-2.png)

> Раннер нас предупреждает, что среда не подготовлена к запуску. Причиной послужила дефолтная конфигурация gitlab-runner, производящая очистку терминала при выходе из оболочки shell. Комментирование строк данного скрипта устраняет данную ошибку

- Закомментируем строки в `/home/gitlab-runner/.bash_logout`

![2.3](images/2-3.png)

### Проверка сборки проекта

- Перезапустим пайплайн и проверим пропала ли ошибка

![2.4](images/2-4.png)

<br>




## Part 3. Тест кодстайла

### Напиcать этап для CI, который запускает скрипт кодстайла (clang-format)

![3.1](images/3-1.png)

### Проверить зафейлился ли пайплайн, если совершена ошибка в кодстайле


![3.2](images/3-2.png)


![3.3](images/3-3.png)


Теперь проект успешно проходит тест кодстайла


<br>




## [Part 4. Интеграционные тесты](#содержание)

### Написать этап для CI, который запускает интеграционные тесты из того же проекта

![4.1](images/4-1.png)

### Проверить зафейлился ли пайплайн, если обнаруживаются ошибочные рузльтаты интеграционных тестов


![4.2](images/4-2.png)


![4.3](images/4-3.png)

Результат работы пайплайна

Проект успешно проходит интеграционные тесты

<br>




## Part 5. Этап деплоя

### Поднять вторую виртуальную машину Ubuntu Server 22.04 LTS

![5.1](images/5-1.png)

### Статическая маршрутизация между двумя машинами

- Настроим адаптеры обоих машин на внутреннюю сеть

> Для удобства раннеровская машина находится в сети с десктопной версией Ubuntu. В дальнейшем консоли обеих машин будут отображаться на десктопной версии

```sh
sudo vim /etc/netplan/00-network-manager-all.yaml
```

![5.2](images/5-2.png)
![5.3](images/5-3.png)

- Обязательно принимаем изменения в настройках адаптеров

```sh
sudo netplan apply
```

- Проверим соединение между машинами

![5.4](images/5-4.png)
![5.4](images/5-5.png)

### Генерация ssh-ключей

- Для начала сгенерируем пары ключей для каждой машины

```sh
ssh-keygen
```
![5.6](images/5-6.png)

- Добавим открытый ключ второй машины с вывода `cat /home/shakitar/.ssh/id_rsa.pub` в ssh ключи gitlab для работы с проектом на удаленной машине

![5.7](images/5-7.png)

### Написать bash-скрипт, который при помощи ssh и scp копирует файлы, полученные после сборки (артефакты), в директорию /usr/local/bin второй виртуальной машины

> Данная часть предполагает создание отдельного скрипта и применение его в стейдже. Так как ранее все скрипты были описаны в `.gitlab-ci.yml`, то, пожалуй, сохраним данную тенденцию, дабы не засорять репозиторий ничем иным. <br>
> Технически команды yml исполняет bash, поэтому будем считать, что "был написан bash-скрипт". <br>

### Написать этап для CD, который «разворачивает» проект на другой виртуальной машине

> Данный этап будет запускаться вручную при условии, что все предыдущие этапы прошли успешно

- Теперь, когда на удаленной машине есть проект, допишем этап деплоя в `.gitlab-ci.yml`

![5.8](images/5-8.png)

> Этап деплоя описан таким образом, что для получения доступа к удаленному серверу применяется ssh-агент. Для его работы необходимо будет выполнить определенный ряд действий

- После пуша обновленного `gitlab-ci.yml` проверяем состояние пайплайна
(во время deploy нужно запускать вручную)

![5.9](images/5-9.png)

![5.10](images/5-10.png)

deploy успешно работает

<br>




## Part 6. Дополнительно. Уведомления

### Настроить уведомления о успешном/неуспешном выполнении пайплайна через бота с именем «shakitar DO6 CI/CD» в Telegram

> Текст уведомления будет содержать информацию об успешности прохождения как этапа CI, так и этапа CD. <br>
> В остальном текст уведомления может быть произвольным.

- Найдем в телеграме через поиск `BotFather`
- Запустим бота и напишем `/newbot`

- имя бота `shakitar DO6 CI/CD» в Telegram` <br>
- юзернейм для бота (имя должно быть уникальным и заканчиваться на `bot`)

![6.1](images/6-1.png)

- Теперь найдем бота `getmyid_bot` и напишем ему `/start` для получения нашего `ID`

![6.2](images/6-2.png)

> добавляем в `gitlab-ci.yml` after_script

![6.3](images/6-3.png)

запускаем нашего бота и обновляем пайплайн

![6.4](images/6-4.png)


